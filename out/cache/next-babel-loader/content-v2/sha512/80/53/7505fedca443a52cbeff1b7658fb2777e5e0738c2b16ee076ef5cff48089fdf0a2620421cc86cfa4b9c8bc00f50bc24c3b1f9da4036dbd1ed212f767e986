{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { combineReducers } from \"redux\";\nimport { createReducer } from \"@reduxjs/toolkit\";\nimport { HYDRATE } from \"next-redux-wrapper\";\nimport * as actions from \"./actions\";\nimport initialState from \"./state\";\nimport { createStore } from \"redux\";\nimport throttle from \"lodash.throttle\";\nconst thingsPageReducer = createReducer(initialState.things_page, builder => {\n  builder.addCase(actions.thingsLoad, (state, action) => {\n    state.loading = true;\n    state.loaded = false;\n    state.error = null;\n  }).addCase(actions.thingsLoadComplete, (state, action) => {\n    state.loading = false;\n    state.loaded = true;\n    if (action.payload.error) state.error = action.payload.error;else state.things = action.payload.things;\n  }).addCase(actions.thingsLoadError, (state, action) => {\n    state.loading = false;\n    state.loaded = true;\n    state.error = action.payload;\n  }).addCase(actions.thingAdd, (state, action) => {\n    state.adding = true;\n  }).addCase(actions.thingAddComplete, (state, action) => {\n    state.adding = false;\n    state.things.unshift(action.payload.thing);\n  }).addCase(actions.thingAddError, (state, action) => {\n    state.adding = false;\n    state.error = action.payload;\n  });\n}); //Board reducer\n\nconst board = (state = {\n  lists: []\n}, action) => {\n  switch (action.type) {\n    case actions.addList:\n      {\n        const {\n          listId\n        } = action.payload;\n        return {\n          lists: [...state.lists, listId]\n        };\n      }\n\n    case actions.moveList:\n      {\n        const {\n          oldListIndex,\n          newListIndex\n        } = action.payload;\n        const newLists = Array.from(state.lists);\n        const [removedList] = newLists.splice(oldListIndex, 1);\n        newLists.splice(newListIndex, 0, removedList);\n        return {\n          lists: newLists\n        };\n      }\n\n    case actions.deleteList:\n      {\n        const {\n          listId\n        } = action.payload;\n\n        const filterDeleted = tmpListId => tmpListId !== listId;\n\n        const newLists = state.lists.filter(filterDeleted);\n        return {\n          lists: newLists\n        };\n      }\n\n    default:\n      return state;\n  }\n}; //ListById reducer\n\n\nconst listsById = (state = {}, action) => {\n  switch (action.type) {\n    case actions.addList:\n      {\n        const {\n          listId,\n          listTitle\n        } = action.payload;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          [listId]: {\n            _id: listId,\n            title: listTitle,\n            cards: []\n          }\n        });\n      }\n\n    case actions.changeListTitle:\n      {\n        const {\n          listId,\n          listTitle\n        } = action.payload;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          [listId]: _objectSpread(_objectSpread({}, state[listId]), {}, {\n            title: listTitle\n          })\n        });\n      }\n\n    case actions.deleteList:\n      {\n        const {\n          listId\n        } = action.payload; //const { [listId]: deletedList, ...restOfLists } = state;\n\n        let newState = _objectSpread({}, state);\n\n        delete newState[listId];\n        return newState;\n      }\n\n    case actions.addCard:\n      {\n        const {\n          listId,\n          cardId\n        } = action.payload;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          [listId]: _objectSpread(_objectSpread({}, state[listId]), {}, {\n            cards: [...state[listId].cards, cardId]\n          })\n        });\n      }\n\n    case actions.moveCard:\n      {\n        const {\n          oldCardIndex,\n          newCardIndex,\n          sourceListId,\n          destListId\n        } = action.payload; // Move within the same list\n\n        if (sourceListId === destListId) {\n          const newCards = Array.from(state[sourceListId].cards);\n          const [removedCard] = newCards.splice(oldCardIndex, 1);\n          newCards.splice(newCardIndex, 0, removedCard);\n          return _objectSpread(_objectSpread({}, state), {}, {\n            [sourceListId]: _objectSpread(_objectSpread({}, state[sourceListId]), {}, {\n              cards: newCards\n            })\n          });\n        } // Move card from one list to another\n\n\n        const sourceCards = Array.from(state[sourceListId].cards);\n        const [removedCard] = sourceCards.splice(oldCardIndex, 1);\n        const destinationCards = Array.from(state[destListId].cards);\n        destinationCards.splice(newCardIndex, 0, removedCard);\n        return _objectSpread(_objectSpread({}, state), {}, {\n          [sourceListId]: _objectSpread(_objectSpread({}, state[sourceListId]), {}, {\n            cards: sourceCards\n          }),\n          [destListId]: _objectSpread(_objectSpread({}, state[destListId]), {}, {\n            cards: destinationCards\n          })\n        });\n      }\n\n    case actions.deleteCard:\n      {\n        const {\n          cardId: deletedCardId,\n          listId\n        } = action.payload;\n\n        const filterDeleted = cardId => cardId !== deletedCardId;\n\n        return _objectSpread(_objectSpread({}, state), {}, {\n          [listId]: _objectSpread(_objectSpread({}, state[listId]), {}, {\n            cards: state[listId].cards.filter(filterDeleted)\n          })\n        });\n      }\n\n    default:\n      return state;\n  }\n}; //Cards By ID reducer\n\n\nconst cardsById = (state = {}, action) => {\n  switch (action.type) {\n    case actions.addCard:\n      {\n        const {\n          cardText,\n          cardId,\n          commentCount,\n          completedTaskCount,\n          taskCount,\n          likeCount,\n          status\n        } = action.payload;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          [cardId]: {\n            text: cardText,\n            _id: cardId,\n            commentCount: commentCount ? commentCount : null,\n            taskCount: taskCount ? taskCount : null,\n            completedTaskCount: completedTaskCount ? completedTaskCount : null,\n            likeCount: likeCount ? likeCount : null,\n            status: status ? status : null\n          }\n        });\n      }\n\n    case actions.changeCardText:\n      {\n        const {\n          cardText,\n          cardId\n        } = action.payload;\n        return _objectSpread(_objectSpread({}, state), {}, {\n          [cardId]: _objectSpread(_objectSpread({}, state[cardId]), {}, {\n            text: cardText\n          })\n        });\n      }\n\n    case actions.deleteCard:\n      {\n        const {\n          cardId\n        } = action.payload; //const { [cardId]: deletedCard, ...restOfCards } = state;\n\n        let newState = _objectSpread({}, state);\n\n        delete newState[cardId];\n        return newState;\n      }\n    // Find every card from the deleted list and remove it\n\n    case actions.deleteList:\n      {\n        const {\n          cards: cardIds\n        } = action.payload;\n        return Object.keys(state).filter(cardId => !cardIds.includes(cardId)).reduce((newState, cardId) => _objectSpread(_objectSpread({}, newState), {}, {\n          [cardId]: state[cardId]\n        }), {});\n      }\n\n    default:\n      return state;\n  }\n}; // Combined state\n// -----------------------------------------------------------------------------\n\n\nconst combinedReducer = combineReducers({\n  things_page: thingsPageReducer,\n  board,\n  listsById,\n  cardsById\n});\n\nfunction rootReducer(state = initialState, action) {\n  switch (action.type) {\n    case HYDRATE:\n      return _objectSpread(_objectSpread({}, state), action.payload);\n\n    default:\n      return combinedReducer(state, action);\n  }\n}\n\nconst saveState = state => {\n  try {\n    const serializedState = JSON.stringify(state);\n    localStorage.setItem(\"state\", serializedState);\n  } catch {// ignore write errors\n  }\n};\n\nconst loadState = () => {\n  try {\n    const serializedState = localStorage.getItem(\"state\");\n\n    if (serializedState === null) {\n      return undefined;\n    }\n\n    return JSON.parse(serializedState);\n  } catch (err) {\n    return undefined;\n  }\n};\n\nconst persistedState = loadState();\nconst store = createStore(combinedReducer, persistedState);\nstore.subscribe(throttle(() => {\n  saveState(store.getState());\n}, 1000));\nconsole.log(store.getState(), JSON.stringify(store.getState()));\n\nif (!store.getState().board.lists.length || store.getState().board.lists.length === 0) {\n  console.log(\"SEED\"); //seed(store);\n}\n\nexport default rootReducer;","map":null,"metadata":{},"sourceType":"module"}